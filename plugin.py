import SimpleITK as sitk
import numpy as np
import pandas as pd
import os
import scipy.io as sio  # to save matlab files (.mat)

from configuration import Configuration
from abc import ABC, abstractmethod
from scipy.ndimage.measurements import label
from imageFormat import NiftiFormat
from utils import get_dst_filename_nifti
from collections import OrderedDict


class Plugin(ABC):
    def __init__(self, name, input_key):
        self.name = name
        self.input_key = input_key       # input key of the dictionary used to read the data generated by other plugin
        super().__init__()

    @abstractmethod
    def process(self, data):
        pass


class LabelPlugin(Plugin):
    def __init__(self, name, input_key):
        self.structure_element = None
        self.ncomponents = None
        self.labeled = None
        super().__init__(name, input_key)

    def set_structure_element(self, dim_x, dim_y, dim_z):
        self.structure_element = np.ones((dim_x, dim_y, dim_z), dtype=np.int)

    def get_structure_element(self):
        return self.structure_element


    def process(self, data):
        print ("> Label plugin with name: '{}' ... ".format(self.name))

        # if already exist an item, then remove it.
        if data.get(self.name) is not None:
            data.pop(self.name)
            print("    Removing from data: '{}':[labeled, ncomponents]".format(self.name))

        # self.input_key[0] equal to 'CT'
        if self.input_key[0] in data:
            print("    {} is a present key in the data dictionary".format(self.input_key[0]))
            _, self.mask = data[self.input_key[0]]

            self.labeled, self.ncomponents = label(self.mask.volume, self.structure_element)
            print("    Labeling labeled ncomponents: {}".format(self.ncomponents))

            # Add the new item to data
            data[self.name] = [self.labeled, self.ncomponents]
            print("    Adding to data: '{}':[labeled, ncomponents]".format(self.name))
            return True

        else:
            print("    Error: In the Labeling, process() method does not found {} key to process.".format(self.input_key[0]))

        return False



class VolumeBBoxPlugin(Plugin):
    def __init__(self, name, input_key):
        self.vbbox_list = []
        super().__init__(name, input_key)

    # Input:  volume (is a mask) where 0 means background and 1 means groundtruth
    # Output: Volume Bounding Box for the volumen: xmin, xma, ymin, ymax, zmin, zmax
    def bbox_3D(self, volume):

        r = np.any(volume, axis=(1, 2))
        c = np.any(volume, axis=(0, 2))
        z = np.any(volume, axis=(0, 1))

        rmin, rmax = np.where(r)[0][[0, -1]]
        cmin, cmax = np.where(c)[0][[0, -1]]
        zmin, zmax = np.where(z)[0][[0, -1]]

        return [rmin, rmax, cmin, cmax, zmin, zmax]

    def process(self, data):
        print("> VolumeBBoxPlugin plugin with name: '{}' ... ".format(self.name))

        # if already exist an item, then remove it.
        if data.get(self.name) is not None:
            data.pop(self.name)
            print("    Removing from data: '{}':vbbox_list".format(self.name))

        # self.input_key[0] equal to 'CT_mask_labeled'
        if self.input_key[0] in data:
            print("    {} is a present key in the data dictionary".format(self.input_key[0]))
            labeled, ncomponents = data[self.input_key[0]]

            self.vbbox_list = []

            # If there is one or more components
            if ncomponents > 0:

                # We artificially add as first item a None, which corresponds to the background.
                # This let us to have label '1' in the index 1, label '2' in the index 2, and so on.
                self.vbbox_list.append(None)

                for i in range(1, ncomponents+1):    # from 1 to (ncomponents+1), with ncomoponents equal to 2 ==> 1,2.
                    mask = np.zeros(labeled.shape, dtype=np.int)
                    mask[np.where(labeled==i)]=1

                    vbbox = self.bbox_3D(mask)   # Find the exact position for the volume bounding box
                    print("    Label: {} has a volume's bbox (xmin, xmax, ymin, ymax, zmin, zmax) = ({})".format(i, vbbox))

                    self.vbbox_list.append(vbbox)
                    del mask

                # ncomponents does not have included the background.
                assert (ncomponents + 1) == len(self.vbbox_list), "    In VolumeBBox, ncomponents must be equal to the amount of vbbox."

                # Add the new item to data
                #self.name equal to 'CT_mask_vbbox'
                data[self.name] = self.vbbox_list
                print("    Adding to data: '{}':vbbox_list".format(self.name))
                return True

        else:
            print('    Error: In the VolumeBBox, process() method does not found CT_mask_labeled key to process.')

        return False



class ExpandVBBoxPlugin(Plugin):
    def __init__(self, name, input_key, strategy):
        self.strategy = strategy        # this is the particular expansion strategy.
        self.expanded_vbbox_list = []
        super().__init__(name, input_key)

    def context_interface(self, labeled, minimal_vbbox, ncomponents, label_number):
        vbbox = self.strategy.expand(labeled, minimal_vbbox, ncomponents, label_number)
        return vbbox

    def process(self, data):
        print("> ExpandVBBox plugin with name: '{}' using {} strategy ... ".format(self.name, self.strategy.name))

        # if already exist an item, then remove it.
        # self.name equal to 'CT_mask_expanded'
        if data.get(self.name) is not None:
            data.pop(self.name)
            print("    Removing from data: '{}':expanded_vbbox_list".format(self.name))

        self.expanded_vbbox_list = []

        # Get some items from data dictionary
        # self.input_key[0] equal to 'CT_mask_labeled' and self.input_key equal[1] equal to 'CT_mask_vbbox'
        if (self.input_key[0] in data) and (self.input_key[1] in data):
            print("    {} and {} are present keys in the data dictionary".format(self.input_key[0], self.input_key[1]))

            labeled, ncomponents = data[self.input_key[0]]
            vbbox_list = data[self.input_key[1]]  # list with minimals vbboxes.

            for label_number, minimal_vbbox in enumerate(vbbox_list):
                if label_number != 0:
                    print("    Label: {}".format(label_number))
                    vbbox = self.context_interface(labeled, minimal_vbbox, ncomponents, label_number)
                    self.expanded_vbbox_list.append(vbbox)
                else:
                    # We artificially add as first item a None, which corresponds to the background.
                    # This let us to have label '1' in the index 1, label '2' in the index 2, and so on.
                    self.expanded_vbbox_list.append(None)

            # ncomponents does not have included the background.
            assert (ncomponents+1)== len(self.expanded_vbbox_list), "    ExpandVBBox, ncomponents must be equal to the amount of vbbox."

            # Add the new item to data
            # self.name equal to 'CT_mask_expanded'
            data[self.name] = self.expanded_vbbox_list
            print("    Adding to data: '{}':expanded_vbbox_list".format(self.name))
            return True
        else:
            print("    Error: In ExpandVBBox, process() method does not found {} and {} keys to process.".format(self.input_key[0], self.input_key[1]))

        return False


class SaveVBBoxNiftiPlugin(Plugin):
    def __init__(self, name, input_key, dst_image_path, dst_mask_path, internal=1):
        self.dst_image_path = dst_image_path
        self.dst_mask_path = dst_mask_path
        self.internal=internal
        # self.image = None
        # self.mask = None
        super().__init__(name, input_key)

    def process(self, data):
        print("> SaveVBBox plugin with name: {} ...".format(self.name))

        # This plugin does not add any item to 'data', thus it is not necessary to
        # check or remove anything from this plugin in the data dictionary.

        #self.input_key[0] equal to 'CT' and self.input_key[1] equal to 'CT_mask_expanded'
        if (self.input_key[0] in data) and (self.input_key[1] in data):
            print("    {} and {} are present keys in the data dictionary".format(self.input_key[0], self.input_key[1]))

            image, mask = data[self.input_key[0]]
            vbbox_list = data[self.input_key[1]]

            # check image and mask must be object from MyNifti class.

            for label_number, vbbox in enumerate(vbbox_list):
                if label_number != 0:       # skipping the background, which has a label = 0.

                    # Mask
                    expanded_mask = NiftiFormat()
                    expanded_mask.volume = np.copy(mask.volume[vbbox[0]:vbbox[1]+1, \
                                                               vbbox[2]:vbbox[3]+1, \
                                                               vbbox[4]:vbbox[5]+1])
                    expanded_mask.array2image()
                    print("    Array2Image: array {} to image {}".format(expanded_mask.volume.shape, expanded_mask.image.GetSize()))
                    expanded_mask.set_properties(properties=mask.get_properties())

                    # Get the names for the image and mask
                    if self.internal == 2:
                        image_fname, mask_fname = image.filename, mask.filename
                    else:
                        # by default
                        image_fname, mask_fname = get_dst_filename_nifti(mask.filename, label_number)

                    expanded_mask.save(self.dst_mask_path, mask_fname)

                    # Image
                    expanded_image = NiftiFormat()
                    expanded_image.volume = np.copy(image.volume[vbbox[0]:vbbox[1]+1, \
                                                                 vbbox[2]:vbbox[3]+1, \
                                                                 vbbox[4]:vbbox[5]+1])
                    expanded_image.array2image()
                    print("    Array2Image: array {} to image {}".format(expanded_image.volume.shape, expanded_image.image.GetSize()))
                    expanded_image.set_properties(properties=image.get_properties())
                    expanded_image.save(self.dst_image_path, image_fname)

            return True

        else:
            print("    Error: In SaveVBBoxNifti, process() method does not found {} and {} keys to process.".format(self.input_key[0], self.input_key[1]))

        return False


class SlidingWindowPlugin(Plugin):
    def __init__(self, name, input_key, slidingWindow, strategy):
        self.slidingWindow = slidingWindow
        self.strategy = strategy
        self.image = None
        self.mask = None
        self.image_filename = ''
        self.mask_filename = ''
        self.caseID = -1
        self.lessionID = -1
        super().__init__(name, input_key)

    def context_interface(self, array, mask, image_filename, mask_filename, caseID, lessionID, origin, spacing, direction):
        df = self.strategy.featureExtraction(array, mask, image_filename, mask_filename, caseID, lessionID, origin, spacing, direction)
        return df

    def process(self, data):
        print("> SlidingWindow plugin with name: {} using strategy {} ...".format(self.name, self.strategy.name))

        # if already exist an item, then remove it.
        if data.get(self.name) is not None:
            data.pop(self.name)
            print("    Removing from data: '{}':[df]".format(self.name))


        #self.input_key[0] equal to 'CT'
        if self.input_key[0] in data:
            print("    {} is a present key in the data dictionary".format(self.input_key[0]))
            self.image, self.mask = data[self.input_key[0]]  # remember that self.image is a MyNifti object.

            # print("   >> origin: {}".format(self.image.origin))
            # print("   >> spacing: {}".format(self.image.spacing))
            # print("   >> direction: {}".format(self.image.direction))

            # adding Pad to the volume
            newVolume = self.slidingWindow.padding(self.image.volume)
            print("    The initial volume's shape is: {}.".format(self.image.volume.shape))
            print("    The Image.Volume has been padded using the method: '{}, now its shape is: {}'.".format(self.slidingWindow.mode, newVolume.shape))

            # little_cubes will contains all the small volumes generated
            # after the window have been shifted throughout the volume.
            # By the way, little_cubes is an numpy object.
            little_cubes = self.slidingWindow.rolling_window(newVolume)


            print("    little_cubes.shape : {}".format(little_cubes.shape))



            if little_cubes is not None:
                # extract features and save them.
                df = self.context_interface(little_cubes, self.mask.volume, self.image.filename, self.mask.filename, self.image.caseID, self.image.lessionID, self.image.origin, self.image.spacing, self.image.direction)
                #self.strategy.featureExtraction(little_cubes)

                # Add the new item to data
                data[self.name] = [df]
                print("    Adding to data: '{}':[df]".format(self.name))

            # if little_cube IS None, it's because the window turned out to be larger than the volume, then there's
            # nothing to do or compute.
            else:
                data[self.name] = [None]
                print("    Adding to data: '{}':[None]".format(self.name))
                print("    Warning: 'lite_cubes' is None.")

            return True

        else:
            print("    Error: In the SlidingWindowPlugin, process() method does not found {} key to process.".format(self.input_key[0]))

        return False


class SaveFeaturesPlugin(Plugin):
    def __init__(self, name, input_key, dst_path, outputFormat, sep, encoding):
        self.image = None
        self.mask = None
        self.image_filename = ''
        self.mask_filename = ''
        self.caseID = -1
        self.lessionID = -1
        self.dst_path = dst_path
        self.outputFormat = outputFormat  # '[csv' | 'xls']
        self.sep = sep
        self.encoding = encoding
        super().__init__(name, input_key)


    def appendDFToCSV_void(self, df, csvFilename, sep=";", encoding='utf-8'):
        """Append new rows to a new or existing .csv file."""
        if not os.path.isfile(csvFilename):
            df.to_csv(csvFilename, mode='a', index=False, sep=sep, encoding=encoding)
        elif len(df.columns) != len(pd.read_csv(csvFilename, nrows=1, sep=sep).columns):
            print("Columns do not match!!")
            raise Exception("Columns do not match!! Dataframe has " + str(len(df.columns)) +
                            " columns. CSV file has " +
                            str(len(pd.read_csv(csvFilename, nrows=1, sep=sep).columns))
                            + " columns.")
        elif not (df.columns == pd.read_csv(csvFilename, nrows=1, sep=sep).columns).all():
            print("Columns and column order of dataframe and csv file do not match!!")
            raise Exception("Columns and column order of dataframe and csv file do not match!!")
        else:
            df.to_csv(csvFilename, mode='a', index=False, sep=sep, encoding=encoding, header=False)

    def process(self, data):
        print("> SaveFeatures plugin with name: {} ...".format(self.name))

        # self.input_key[0] equal to 'CT' and self.input_key[0] equal to 'mySlidingWindowPlugin'
        if (self.input_key[0] in data) and (self.input_key[1] in data):
            print("    {} is a present key in the data dictionary".format(self.input_key[0]))
            self.image, self.mask = data[self.input_key[0]]  # remember that self.image is a MyNifti object.

            [df] = data[self.input_key[1]]  # remember that self.image is a MyNifti object.

            filename = os.path.join(self.dst_path, self.image.filename.split('.')[0])

            if df is not None:
                # CSV format
                if self.outputFormat == 'csv':
                    filename += '.csv'
                    if not os.path.isfile(filename):
                        df.to_csv(filename, index=False, sep=self.sep, encoding=self.encoding)
                    else:
                        print("Error: there is already a file named {}. Remove it!!".format(filename))
                        raise Exception("There is already a file named {}. Remove it!!!!")
                # XLS format
                elif self.outputFormat == 'xlsx':
                    filename += '.xlsx'
                    if not os.path.isfile(filename):
                        # Create a Pandas Excel writer using XlsxWriter as the engine.
                        writer = pd.ExcelWriter(filename, engine='xlsxwriter')
                        # Convert the dataframe to an XlsxWriter Excel object.
                        df.to_excel(writer, sheet_name='Sheet1', index=False)
                        # Close the Pandas Excel writer and output the Excel file.
                        writer.save()
                    else:
                        print("Error: there is already a file named {}. Remove it!!".format(filename))
                        raise Exception("There is already a file named {}. Remove it!!!!".format(filename))
                # NPZ numpy array format
                elif self.outputFormat == 'npz':

                    # TODO: pass by parameters the range of ncols
                    ncols = list(range(9, 97))
                    selected = df[df.columns[ncols]]

                    array_lst = []
                    for col in selected.columns:
                        #vol = np.zeros(self.mask.volume.shape, dtype=np.float)

                        z, x, y = self.mask.volume.shape

                        feature = df[col]   # <class 'pandas.core.series.Series'>
                        feature = np.array(feature)  # cast to <class 'numpy.ndarray'>
                        #print("type(feature): {}".format(type(feature)))
                        #print("feature.shape: {}".format(feature.shape))

                        index = np.array(df['flattened_index'])  # recover indexes and cast to numpy array.

                        feature2 = 0*feature
                        feature2[index] = feature
                        feature2 = feature2.reshape(x, y, z)

                        # if col == 'original_firstorder_90Percentile':
                        #     print("col '{}': {}".format(col, feature2[0,4,2]))
                        #     print("col '{}': {}".format(col, feature2[1,0,3]))

                        array = np.copy(feature2)

                        array_lst.append((col, array))

                    od = OrderedDict(array_lst)
                    np.savez(filename, **od)

                # MATLAB format (.mat)
                elif self.outputFormat == 'mat':
                    # It is supposed that already the arrays are saved in .npz file.
                    try:
                        npzfile = np.load(filename+'.npz')
                        sio.savemat(filename, npzfile)
                    except IOError:
                        print("An error occured trying to read the file: {}.".format(filename+'.npz'))




                # self.appendDFToCSV_void(df=df, csvFilename=csvFilename, sep=self.sep, encoding=self.enconding)
                print("      Writing {} rows to: {}".format(len(df), filename))
            else:
                print("      Warning: there is not any row to be written for the file: {}".format(self.image.filename))

            return True

        else:
            print("    Error: In the SlidingWindowPlugin, process() method does not found {} key to process.".format(
                self.input_key[0]))

        return False





def debug_test():
    from utils import get_components
    from input import NiftiManagementPlugin
    from expansionStrategy import Bg_pExpansion

    config = Configuration("config/conf_extractfeatures.py", "extract features").load()

    data = {}

    # Plugin NiftiManagement
    myNiftiHandler = NiftiManagementPlugin('myNiftiHandler',
                                           config.src_image_path,
                                           config.src_mask_path,
                                           config.mask_pattern,
                                           config.dst_image_path,
                                           config.dst_mask_path)
    myNiftiHandler.masks2read()
    myNiftiHandler.process(config, data)



    # Plugin Labeling
    labeling = LabelPlugin('labeling')
    dim_x, dim_y, dim_z = get_components(config.labeling_se_dim)
    labeling.set_structure_element(dim_x, dim_y, dim_z)
    labeling.process(data)

    # Plugin VolumeBBox
    volumeBBox =  VolumeBBoxPlugin('volumeBBox')
    volumeBBox.process(data)

    # Plugin UniformExpandVBBox
    uniformExpansionVBBox = Bg_pExpansion('uniform', config.background_p, config.groundtruth_p, config.nvoxels, config.check_bg_percentage)
    expandVBBox = ExpandVBBoxPlugin('expand_vbbox', uniformExpansionVBBox)
    expandVBBox.process(data)

    # Plugin SaveVBBoxNifti
    saveVBBoxNifti = SaveVBBoxNiftiPlugin('SaveVBBoxNifti', config.dst_image_path, config.dst_mask_path)
    saveVBBoxNifti.process(data)


if __name__ == '__main__':
    debug_test()
    #test()

