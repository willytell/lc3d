import SimpleITK as sitk
import numpy as np
import os

from configuration import Configuration
from abc import ABC, abstractmethod
from scipy.ndimage.measurements import label
from imageFormat import NiftyFormat
from utils import get_dst_filename_nifty
from slidingwindow import SlidingWindow

class Plugin(ABC):
    def __init__(self, name, input_key):
        self.name = name
        self.input_key = input_key       # input key of the dictionary used to read the data generated by other plugin
        super().__init__()

    @abstractmethod
    def process(self, data):
        pass


class LabelPlugin(Plugin):
    def __init__(self, name, input_key):
        self.structure_element = None
        self.ncomponents = None
        self.labeled = None
        super().__init__(name, input_key)

    def set_structure_element(self, dim_x, dim_y, dim_z):
        self.structure_element = np.ones((dim_x, dim_y, dim_z), dtype=np.int)

    def get_structure_element(self):
        return self.structure_element


    def process(self, data):
        print ("Label plugin with name: '{}' ... ".format(self.name))

        # if already exist an item, then remove it.
        if data.get(self.name) is not None:
            data.pop(self.name)
            print("Removing to data: '{}':[labeled, ncomponents]".format(self.name))

        # self.input_key[0] equal to 'CT'
        if self.input_key[0] in data:
            print("{} is a present key in the data dictionary".format(self.input_key[0]))
            _, self.mask = data[self.input_key[0]]

            self.labeled, self.ncomponents = label(self.mask.volume, self.structure_element)
            print("Labeling labeled ncomponents: {}".format(self.ncomponents))

            # Add the new item to data
            data[self.name] = [self.labeled, self.ncomponents]
            print("Adding to data: '{}':[labeled, ncomponents]".format(self.name))
            return True

        else:
            print("Error: In the Labeling, process() method does not found {} key to process.".format(self.input_key[0]))

        return False



class VolumeBBoxPlugin(Plugin):
    def __init__(self, name, input_key):
        self.vbbox_list = []
        super().__init__(name, input_key)

    # Input:  volume (is a mask) where 0 means background and 1 means groundtruth
    # Output: Volume Bounding Box for the volumen: xmin, xma, ymin, ymax, zmin, zmax
    def bbox_3D(self, volume):

        r = np.any(volume, axis=(1, 2))
        c = np.any(volume, axis=(0, 2))
        z = np.any(volume, axis=(0, 1))

        rmin, rmax = np.where(r)[0][[0, -1]]
        cmin, cmax = np.where(c)[0][[0, -1]]
        zmin, zmax = np.where(z)[0][[0, -1]]

        return [rmin, rmax, cmin, cmax, zmin, zmax]

    def process(self, data):
        print("VolumeBBoxPlugin plugin with name: '{}' ... ".format(self.name))

        # if already exist an item, then remove it.
        if data.get(self.name) is not None:
            data.pop(self.name)
            print("Removeing to data: '{}':vbbox_list".format(self.name))

        # self.input_key[0] equal to 'CT_mask_labeled'
        if self.input_key[0] in data:
            print("{} is a present key in the data dictionary".format(self.input_key[0]))
            labeled, ncomponents = data[self.input_key[0]]

            self.vbbox_list = []

            # If there is one or more components
            if ncomponents > 0:

                # We artificially add as first item a None, which corresponds to the background.
                # This let us to have label '1' in the index 1, label '2' in the index 2, and so on.
                self.vbbox_list.append(None)

                for i in range(1, ncomponents+1):    # from 1 to (ncomponents+1), with ncomoponents equal to 2 ==> 1,2.
                    mask = np.zeros(labeled.shape, dtype=np.int)
                    mask[np.where(labeled==i)]=1

                    vbbox = self.bbox_3D(mask)   # Find the exact position for the volume bounding box
                    print("For the label {} its volume bbox is (xmin, xmax, ymin, ymax, zmin, zmax) = ({})".format(i, vbbox))

                    self.vbbox_list.append(vbbox)
                    del mask

                # ncomponents does not have included the background.
                assert (ncomponents + 1) == len(self.vbbox_list), "In VolumeBBox, ncomponents must be equal to the amount of vbbox."

                # Add the new item to data
                #self.name equal to 'CT_mask_vbbox'
                data[self.name] = self.vbbox_list
                print("Adding to data: '{}':vbbox_list".format(self.name))
                return True

        else:
            print('Error: In the VolumeBBox, process() method does not found CT_mask_labeled key to process.')

        return False



class ExpandVBBoxPlugin(Plugin):
    def __init__(self, name, input_key, strategy):
        self.strategy = strategy        # this is the particular expansion strategy.
        self.expanded_vbbox_list = []
        super().__init__(name, input_key)

    def context_interface(self, labeled, minimal_vbbox, ncomponents, label_number):
        vbbox = self.strategy.expand(labeled, minimal_vbbox, ncomponents, label_number)
        return vbbox

    def process(self, data):
        print("ExpandVBBox plugin with name: '{}' using {} strategy ... ".format(self.name, self.strategy.name))

        # if already exist an item, then remove it.
        # self.name equal to 'CT_mask_expanded'
        if data.get(self.name) is not None:
            data.pop(self.name)
            print("Removeing to data: '{}':expanded_vbbox_list".format(self.name))

        self.expanded_vbbox_list = []

        # Get some items from data dictionary
        # self.input_key[0] equal to 'CT_mask_labeled' and self.input_key equal[1] equal to 'CT_mask_vbbox'
        if (self.input_key[0] in data) and (self.input_key[1] in data):
            print("{} and {} are present keys in the data dictionary".format(self.input_key[0], self.input_key[1]))

            labeled, ncomponents = data[self.input_key[0]]
            vbbox_list = data[self.input_key[1]]  # list with minimals vbboxes.

            for label_number, minimal_vbbox in enumerate(vbbox_list):
                if label_number != 0:
                    vbbox = self.context_interface(labeled, minimal_vbbox, ncomponents, label_number)
                    self.expanded_vbbox_list.append(vbbox)
                else:
                    # We artificially add as first item a None, which corresponds to the background.
                    # This let us to have label '1' in the index 1, label '2' in the index 2, and so on.
                    self.expanded_vbbox_list.append(None)

            # ncomponents does not have included the background.
            assert (ncomponents+1)== len(self.expanded_vbbox_list), "ExpandVBBox, ncomponents must be equal to the amount of vbbox."

            # Add the new item to data
            # self.name equal to 'CT_mask_expanded'
            data[self.name] = self.expanded_vbbox_list
            print("Adding to data: '{}':expanded_vbbox_list".format(self.name))
            return True
        else:
            print("Error: In ExpandVBBox, process() method does not found {} and {} keys to process.".format(self.input_key[0], self.input_key[1]))

        return False


class SaveVBBoxNiftyPlugin(Plugin):
    def __init__(self, name, input_key, dst_image_path, dst_mask_path):
        self.dst_image_path = dst_image_path
        self.dst_mask_path = dst_mask_path
        # self.image = None
        # self.mask = None
        super().__init__(name, input_key)

    def process(self, data):
        print("SaveVBBox plugin with name: {} ...".format(self.name))

        # This plugin does not add any item to 'data', thus it is not necessary to
        # check or remove anything from this plugin in the data dictionary.

        #self.input_key[0] equal to 'CT' and self.input_key[1] equal to 'CT_mask_expanded'
        if (self.input_key[0] in data) and (self.input_key[0] in data):
            print("{} and {} are present keys in the data dictionary".format(self.input_key[0], self.input_key[1]))

            image, mask = data[self.input_key[0]]
            vbbox_list = data[self.input_key[1]]

            # check image and mask must be object from MyNifty class.

            for label_number, vbbox in enumerate(vbbox_list):
                if label_number != 0:       # skipping the background, which has a label = 0.

                    # Mask
                    expanded_mask = NiftyFormat()
                    expanded_mask.volume = np.copy(mask.volume[vbbox[0]:vbbox[1]+1, \
                                                               vbbox[2]:vbbox[3]+1, \
                                                               vbbox[4]:vbbox[5]+1])
                    expanded_mask.array2image()
                    expanded_mask.set_properties(properties=mask.get_properties())
                    # Get the names for the image and mask
                    image_fname, mask_fname = get_dst_filename_nifty(mask.filename, label_number)
                    expanded_mask.save(self.dst_mask_path, mask_fname)

                    # Image
                    expanded_image = NiftyFormat()
                    expanded_image.volume = np.copy(image.volume[vbbox[0]:vbbox[1]+1, \
                                                                 vbbox[2]:vbbox[3]+1, \
                                                                 vbbox[4]:vbbox[5]+1])
                    expanded_image.array2image()
                    expanded_image.set_properties(properties=image.get_properties())
                    expanded_image.save(self.dst_image_path, image_fname)

            return True

        else:
            print("Error: In SaveVBBoxNifty, process() method does not found {} and {} keys to process.".format(self.input_key[0], self.input_key[1]))

        return False


class SlidingWindowPlugin(Plugin):
    def __init__(self,name, input_key, slidingWindow, strategy):
        self.slidingWindow = slidingWindow
        self.strategy = strategy
        self.image = None
        super().__init__(name, input_key)

    def context_interface(self, array, origin, spacing, direction):
        self.strategy.featureExtraction(array, origin, spacing, direction)

    def process(self, data):
        print("SlidingWindow plugin with name: {} using strategy {} ...".format(self.name, self.strategy.name))

        #self.input_key[0] equal to 'CT'
        if self.input_key[0] in data:
            print("{} is a present key in the data dictionary".format(self.input_key[0]))
            self.image, _ = data[self.input_key[0]]  # remember that self.image is a MyNifty object.

            # print("   >> origin: {}".format(self.image.origin))
            # print("   >> spacing: {}".format(self.image.spacing))
            # print("   >> direction: {}".format(self.image.direction))

            # adding Pad to the volume
            newVolume = self.slidingWindow.padding(self.image.volume)
            print("The Volume has been padded using the method: '{}, now its shape is: {}'.".format(self.slidingWindow.mode, newVolume.shape))

            # little_cubes will contains all the small volumes generated
            # after the window have been shifted throughout the volume.
            # By the way, little_cubes is an numpy object.
            little_cubes = self.slidingWindow.rolling_window(newVolume)

            if little_cubes is not None:
                # extract features and save them.
                self.context_interface(little_cubes, self.image.origin, self.image.spacing, self.image.direction)
                #self.strategy.featureExtraction(little_cubes)
            # if little_cube IS None, it's because the window turned out to be larger than the volume, then there's
            # nothing to do or compute.

            return True

        else:
            print("Error: In the SlidingWindowPlugin, process() method does not found {} key to process.".format(self.input_key[0]))

        return False




def debug_test():
    from utils import get_components
    from input import NiftyManagementPlugin
    from expansionStrategy import Bg_pExpansion

    config = Configuration("config/conf_extractfeatures.py", "extract features").load()

    data = {}

    # Plugin NiftyManagement
    myNiftyHandler = NiftyManagementPlugin('myNiftyHandler',
                                           config.src_image_path,
                                           config.src_mask_path,
                                           config.mask_pattern,
                                           config.dst_image_path,
                                           config.dst_mask_path)
    myNiftyHandler.masks2read()
    myNiftyHandler.process(config, data)



    # Plugin Labeling
    labeling = LabelPlugin('labeling')
    dim_x, dim_y, dim_z = get_components(config.labeling_se_dim)
    labeling.set_structure_element(dim_x, dim_y, dim_z)
    labeling.process(data)

    # Plugin VolumeBBox
    volumeBBox =  VolumeBBoxPlugin('volumeBBox')
    volumeBBox.process(data)

    # Plugin UniformExpandVBBox
    uniformExpansionVBBox = Bg_pExpansion('uniform', config.background_p, config.groundtruth_p, config.nvoxels, config.check_bg_percentage)
    expandVBBox = ExpandVBBoxPlugin('expand_vbbox', uniformExpansionVBBox)
    expandVBBox.process(data)

    # Plugin SaveVBBoxNifty
    saveVBBoxNifty = SaveVBBoxNiftyPlugin('SaveVBBoxNifty', config.dst_image_path, config.dst_mask_path)
    saveVBBoxNifty.process(data)


if __name__ == '__main__':
    debug_test()
    #test()

